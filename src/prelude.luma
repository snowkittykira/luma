#string: #
  [a .= b]: &= a b
  [. .? a]: &string? a

  [a .=  b]: [&=  a b]
  [a .~= b]: [&~= a b]
  [a .<  b]: [&<  a b]
  [a .>  b]: [&>  a b]
  [a .<= b]: [&<= a b]
  [a .>= b]: [&>= a b]

  [self.length        ]: &string-length self
  [self.substring i j ]: &string-substring self i j
  [self.contains? other]: &string-contains? self other
  [self.concat   other]: &string-concat self other
  [self.utf8-char-at i]: &utf8-char-at self i
  [self.to-number]:
    num: &string-to-number self
    or num false
  [self.to-string]: self

#bool: #
  [a .= b]: &= a b
  [. .? a]: &bool? a
  [a .to-string]: &value-to-string a

#number: #
  [. .? a]: &number? a

  [a .to-string]: &value-to-string a

  [a .+  b]: &+  a b
  [a .-  b]: &-  a b
  [a .*  b]: &*  a b
  [a ./  b]: &/  a b
  [a .=  b]: &=  a b
  [a .~= b]: &~= a b
  [a .<  b]: &<  a b
  [a .>  b]: &>  a b
  [a .<= b]: &<= a b
  [a .>= b]: &>= a b
  [a .sqrt]: &sqrt a

else: true

[not a]: if a false true

[+  a b]: a .+  b
[-  a b]: a .-  b
[*  a b]: a .*  b
[/  a b]: a ./  b
[=  a b]: a .=  b
[~= a b]: a .~= b
[<  a b]: a .<  b
[>  a b]: a .>  b
[<= a b]: a .<= b
[>= a b]: a .>= b

#collection: #
  [self.each f]: self.iterator.each f
  [self.all? f]: self.iterator.all? f

#list: # #collection
  [. .? a]: has? a #list

  [.]: #list.nil
  [. a b..]: #list.link a [#list b..]

  [. .link first rest]: 
    assert [#list.? rest] 'tried to link to non-list'
    # #list
      .first: first
      .rest: rest

  [. .nil]: nil

  [self.iterator]: #list-iterator self
  [self.empty?]: is? self nil

  [self.get i]:
    assert [not self.empty?] 'tried to get element from past end of list'
    if [i .> 0]
      self.rest.get [i .- 1]
      self.first

  [self.drop i]:
    assert [or [i .= 0] [not self.empty?]] 'tried to drop more elements than in list'
    if [i .> 0]
      self.rest.drop [i .- 1]
      self

  [self.length]:
    if self.empty?
      0
      + 1 self.rest.length

  [self.map f]: [self.iterator.map f].to-list

  append: #
    [. list]:
      assert [#list.? list] 'tried to append non-list'
      list
    [. list lists..]:
      assert [#list.? list] 'tried to append non-list'
      if list.empty?
        append lists..
        [#list.link list.first [append list.rest lists..]]

  (for some reason the interpreter fails if i try and implement .append as a field)
  [. .append lists..]: append lists..

  [self.last]:
    assert [not self.empty?] 'cant get last item of empty list'
    if self.rest.empty?
      self.first
      self.rest.last

  [self.without-last]:
    assert [not self.empty?] 'cant remove last item of empty list'
    if self.rest.empty?
      #list.nil
      #list.link self.first self.rest.without-last

  [self.reverse]:
    result: [#list]
    self.each [. i]:
      set result [#list.link i result]
    result

(can't create this in #list because it doesn't work if i do)
(probably i can't make instances of classes before the class is finished being defined)
nil: # #list

#iterator: #
  [self.map f]: # #iterator
    [. .empty?]: self.empty?
    [. .item]: f self.item
    [. .advance]: self.advance

  [self.each f]:
    while [not self.empty?]:
      f self.item
      self.advance

  [self.to-list]:
    [loop]:
      when
        self.empty?:
          #list.nil
        else:
          first: self.item
          self.advance
          #list.link first [loop]
    [loop]

  [self.to-array]:
    array: [#array]
    while [not self.empty?]:
      array.push self.item
      self.advance
    array

  [self.skip n]:
    while [0 .< n]:
      set n [n .- 1]
      self.advance
    self

  [self.all? f]:
    result: true
    while [and result [not self.empty?]]:
      set result [f self.item]
      self.advance
    result

#list-iterator: # #iterator
  [. list]: # #list-iterator
    .list: list
  [self.empty?]:  self.list.empty?
  [self.item]:    self.list.first
  [self.advance]: set self.list self.list.rest

#array: # #collection
  [. .? a]: has? a #array

  [.]: # #array
    .length: 0

  [. a..]:
    array: [#array]
    loop: #
      [.]: false
      [. a b..]:
        array.push a
        loop b..
    [loop a..]
    array

  [. .append lists..]:
    result: [#array]
    [#array lists..].each [. a]:
      result.push-items a
    result

  [self.get i]:
    &lua-get-index self i

  [self.set i v]:
    assert [0 .<= i] 'index out of range'
    assert [i .< self.length] 'index out of range'
    &lua-set-index self i v

  [self.push a]:
    &lua-set-index self self.length a
    set self.length [self.length .+ 1]

  [self.pop]:
    assert [0 .< self.length] 'cant pop empty array'
    set self.length [self.length .- 1]
    value: &lua-get-index self self.length
    &lua-remove-index self self.length
    value

  [self.peek]:
    assert [0 .< self.length] 'cant peek empty array'
    self.get [self.length .- 1]

  [self.push-items items]:
    items.each [. i]: [self.push i]

  [self.iterator]: #array-iterator self

  [self.drop n]: [self.iterator.skip n].to-array

  [self.drop-last n]:
    result: [#array]
    i: 0
    end: self.length .- n
    while [i .< end]:
      result.push [self.get i]
      set i [i .+ 1]
    result

  [self.last]:
    self.get [self.length .- 1]

  [self.map f]:
    result: [#array]
    i: 0
    len: self.length
    while [i .< len]:
      result.push [f [self.get i]]
      set i [i .+ 1]
    result

  [self.concat]:
    (todo: rename to concat-strings)
    &lua-concat self

  [self.sort le-fn]:
    sorted: 1
    while [sorted .< self.length]:
      value: self.get sorted
      i: sorted
      while [and [0 .< i] [not [le-fn [self.get [i .- 1]] value]]]:
        self.set i [self.get [i .- 1]]
        set i [i .- 1]
      self.set i value
      set sorted [sorted .+ 1]

  (TODO: ideally iterator.each would just be fast enough)
  [self.each f]:
    i: 0
    end: self.length
    while [i .< end]:
      f [self.get i]
      set i [i .+ 1]

#array-iterator: # #iterator
  [. array]: # #array-iterator
    .array: array
    .index: 0
  [self.empty?]:  self.array.length .<= self.index
  [self.item]:    self.array.get self.index
  [self.advance]:
    assert [not self.empty?]
    set self.index [self.index .+ 1]

#hash: #
  [. .? a]: has? a #hash

  [.]: # #hash
    .%index: [#]

  [. pairs..]:
    hash: [#hash]
    loop: #
      [.]: false
      [. pair pairs..]:
        hash.set pair.key pair.value
        loop pairs..
    [loop pairs..]
    hash

  [self.has? key]:
    &lua-has-index? self.%index key

  [self.set key value]:
    &lua-set-index self.%index key value

  [self.get key]:
    &lua-get-index self.%index key

  [self.get-or key default]:
    if [self.has? key]
      &lua-get-index self.%index key
      default

  [self.remove key]:
    &lua-remove-index self.%index key

  [self.key-iterator]:
    #hash-key-iterator self

  [self.pair-iterator]:
    self.key-iterator.map [. key]:
      #pair key [self.get key]

#hash-key-iterator: # #iterator
  [. hash]: # #hash-key-iterator
    .hash: hash
    .first?: true
    .key: false

  (todo: redesign the low level interface to make this cleaner)
  [self.empty?]: if self.first?
    not [&lua-has-next-index? self.hash.%index]
    not [&lua-has-next-index? self.hash.%index self.key]
  [self.item]: if self.first?
    &lua-next-index self.hash.%index
    &lua-next-index self.hash.%index self.key
  [self.advance]:
    assert [not self.empty?]
    set self.key self.item
    set self.first? false

#pair: #
  [. .? a]: has? a #pair

  [. key value]: # #pair
    .key: key
    .value: value

[read-file name]:
  &read-file name

[write-file name data]:
  [&write-file name data]

[quote-string str]:
  &quote-string str

[safe-identifier str]:
  &safe-identifier str

[combine-strings items..]:
  (combines lists-of-lists..-of-strings)
  [flatten-to-array list]:
    flat-array: [#array]
    [flatten-loop items]:
      items.iterator.each [. item]:
        if [#string.? item]
          flat-array.push item
          flatten-loop item
    [flatten-loop list]
    flat-array
  [flatten-to-array [#array items..]].concat

[get-args n]:
  arg: [&args n]
  if arg
    #list.link arg [get-args [+ n 1]]
    [#list]

[get-time]:
  [&get-time]

command-line-args: get-args 1

#
  .#bool: #bool
  .#string: #string
  .#number: #number
  .else: else
  .not: not
  .+: +
  .-: -
  .*: *
  ./: /
  .=: =
  .~=: ~=
  .<: <
  .>: >
  .<=: <=
  .>=: >=
  .#collection: #collection
  .#list: #list
  .#array: #array
  .#hash: #hash
  .#pair: #pair
  .read-file: read-file
  .write-file: write-file
  .quote-string: quote-string
  .safe-identifier: safe-identifier
  .combine-strings: combine-strings
  .command-line-args: command-line-args
  .get-time: get-time
